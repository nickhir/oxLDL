---
title: "RNA seq qc"
author: "Nick Hirschmuller"
date: "`r format(Sys.time(), '%d %B, %Y')`"
always_allow_html: yes
output:
  html_document:
    word_document:
    toc: yes
    toc_depth: '3'
    code_folding: hide
  pdf_document:
    number_sections: yes
    toc: false
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    echo = T, warning = F, error = F, message = F,
    fig.align = "center", cache = F, dpi = 350
)
```

## **Introduction**
The [nf-core RNAseq pipeline](https://github.com/nf-core/rnaseq) already does a very extensive set of quality control steps 
based on the read level (for example # Duplicated reads, GC content, 
mapping rate, read distribution, â€¦). 
In this script, we will do some qulaity control steps based on the 
quantified counts (using [STAR](https://github.com/alexdobin/STAR) followed by [salmon](https://combine-lab.github.io/salmon/)).
 We will also make a few plots to explore the metadata


```{r, load libraries}
library(DESeq2)
library(magrittr)
library(PCAtools)
library(tidyverse)
library(umap)
library(patchwork)
library(httpgd)

library(here)
source(here("plot_theme.R"))
source(here("helper_functions.R"))
```



```{r}
plot_column_table <- function(input_vector, include_n=FALSE) {
  # Convert input vector to data frame
  data_df <- data.frame(values = input_vector)
  
  # Create the ggplot barplot
  plot <- ggplot(data_df, aes(x = values)) +
      geom_bar(fill = "#0f8fc2", color = "black") +
      labs(title = "Frequency of Elements", x = "Elements", y = "Frequency") +
      scale_y_continuous(expand = c(0.01, 0)) +
      theme_Publication()
  
  if(include_n){
    data_summary <- data_df %>%
        group_by(values) %>%
        summarise(count = n())
    
    max_count <- max(data_summary$count)
    y_max <- max_count*1.25   # Increase by 20% to add a buffer

    plot <- plot +
        geom_text(
            data = data_summary, aes(label = count, y = count),
            vjust = -0.5, color = "black", size = 4
        )+
        scale_y_continuous(expand = c(0.01, 0), limits=c(0,y_max))
  }
  return(plot)
}
```
## **Description of metadata**
Few observations: 
(a) A few important confounders (e.g. `age`, `ethnicity`) are missing for some samples 
(b) There seem to be a few technical replicates (cell lines that were used more than 6 times) 
(c) MM_oxLDL7159504 seems to contain conflicting information. 
oxLDL treated according to column `oxLDL` but control according to column `sampeltype`.

```{r}
mdata <- readxl::read_excel(here("data", "mdata_google_spreadsheet.xlsx"),
    sheet = "RNA Sequencing samples"
) %>% data.frame()

submission_mdata <- data.table::fread(here("data", "oxLDL_data", "RNA_seq", "macromap_samplesheet.csv"),
    data.table = FALSE
)
mdata$ethnicity <- ifelse(mdata$ethnicity == "White - White other", "White - Other", mdata$ethnicity)
mdata$ethnicity <- ifelse(mdata$ethnicity == "Asian /Asian British- Indian", "Asian British- Indian", mdata$ethnicity)
factor_columns <- c("state", "oxldl", "set", "ethnicity", "pool", "age", "batch1id", "oxldlset")
mdata[factor_columns] <- lapply(mdata[factor_columns], factor)

stopifnot(all(mdata$sampleid %in% submission_mdata$sample))
stopifnot(n_distinct(mdata$sampleid) == nrow(mdata))
mdata %>%
    filter(grepl("_0", sampletype)) %>%
    filter(oxldl != 0)
mdata %>%
    filter(grepl("_oxLDL", sampletype)) %>%
    filter(oxldl != 100)

age <- plot_column_table(mdata$age, include_n = T) +
    ggtitle("Age distribution") +
    xlab("Age") +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))

rna_pool <- plot_column_table(mdata$pool %>%
    str_remove_all("RNA ") %>%
    factor(., levels = c("pilot", as.character(1:17))), include_n=TRUE) +
    ggtitle("RNA pool distribution") +
    xlab("RNA pool")


type <- plot_column_table(mdata$state, include_n = T) +
    ggtitle("Macrophage type distribution") +
    xlab("Macrophage type")

# some lines have more than the expected number (6) of entries. Take a look at them
# we might have to remove one of them because they are technical replicates and not biological ones.
lines <- plot_column_table(mdata$line) +
    ggtitle("Cell line distribution") +
    xlab("Cell lines") +
    theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank()
    )

# simple technical replicates sometimes, even in the same RNA pool and batch
# for example MM_oxLDL9752052 and MM_oxLDL9752058
mdata %>%
    group_by(line) %>%
    mutate(n_lines = n()) %>%
    filter(n_lines > 6) %>%
    arrange(line) 

condition <- plot_column_table(ifelse(mdata$oxldl == "100", "stimulated", "unstimulated"),
    include_n = T
)+
    ggtitle("Condition distribution") +
    xlab("Condition")


oxLDL_set <- plot_column_table(factor(mdata$oxldlset))+
    ggtitle("oxLDL set distribution") +
    xlab("oxLDL set") +
    theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank()
    )

sex <- plot_column_table(mdata$set, include_n = TRUE) +
    ggtitle("Sex distribution") +
    xlab("Sex")

ethnicity_vector <- mdata %>%
    distinct(line, .keep_all = TRUE) %>%
    pull(ethnicity)

ethnicity <- plot_column_table(
    factor(ethnicity_vector,
        levels = c("White - White British", "White - Other", "Asian British- Indian", "NA")
    ),
    include_n = TRUE
) +
    ggtitle("Ethnicity") +
    xlab("Ethnicity") +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))

batches <- plot_column_table(as.character(mdata$batch1id), include_n = TRUE)+
    ggtitle("Batches distribution") +
    xlab("Batch")+
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))

    # combine the plots
combined_plot <- wrap_plots(
    age, sex, ethnicity,
    lines, oxLDL_set, batches,
    type, condition,
    ncol = 3,
    byrow = TRUE
)
ggsave(combined_plot,
    filename = here("QC", "results", "imgs", "mdata_overview.png"), 
    dpi = 350, width = 18, height = 8
)
```

## **Count data quality control**
Read in the count data generated by the pipeline. They were slightly modified using the 
script preprocessing/scripts/unify_geneID_to_geneName.rmd


Clearly strong batch effects. Main culprits are:
(a) batch1id
(b) pool (overlaps with batch1id)
(c) age

Our variables of interest seem to not associate with any PCs.
 
```{r}
raw_counts <- data.table::fread(
    here("preprocessing", "results", "gene_counts_length_scaled_filtered.tsv")
) %>% data.frame()

raw_counts_matrix <- as.matrix(raw_counts[,2:ncol(raw_counts)])
rownames(raw_counts_matrix) <- raw_counts$gene_name

# make sure mdata order matches the column names of raw_counts
mdata <- mdata[match(colnames(raw_counts_matrix), mdata$sampleid), ]
rownames(mdata) <- mdata$sampleid

dds0 <- DESeqDataSetFromMatrix(round(raw_counts_matrix),
    colData = mdata,
    design = ~1
)
# remove some lowly expressed genes
keep <- edgeR::filterByExpr(counts(dds0), group = mdata$sampletype)
dds0 <- dds0[keep,]
vsd_data <- vst(dds0)
norm_data <- assay(vsd_data)
```



```{r}
#################
# CALCULATE PCA #
#################
pca_data <- PCAtools::pca(norm_data,
    metadata = colData(dds0),
    removeVar = 0.4
)
pca_plot_df <- pca_data$rotated[, 1:20] %>%
    rownames_to_column("sample_id") %>%
    left_join(., mdata, by = c("sample_id" = "sampleid"))
for (i in 1:20) {
    pca_plot_df[, str_interp("PC${i}_explained_var")] <- pca_data$variance[i]
}

##################
# CALCULATE UMAP #
##################
umap_data <- umap(t(norm_data))
umap_plot_df <- umap_data$layout %>%
    data.frame() %>%
    magrittr::set_colnames(c("UMAP1", "UMAP2")) %>%
    rownames_to_column("sampleid") %>% 
    left_join(., mdata)

###########
# HEATMAP #
###########
association_output <- covar_correlation(
    df = pca_plot_df,
    covars = c("pool", "state", "oxldl", "oxldlset", "set", "ethnicity", "age", "batch1id"),
    components = paste0("PC", 1:15)
)

png(here("QC", "results", "imgs", "association_heatmap.png"), res=350, width=9, height=5.5, units="in")
association_output$heatmap
dev.off()

#############
# PCA PLOTS #
#############
columns_to_plot <- c("state", "oxldl", "set", "ethnicity", "pool", "age", "batch1id")

plots <- lapply(columns_to_plot, function(x) {
    p <- density_pca(
        df = pca_plot_df,
        x_variable = "PC1",
        y_variable = "PC2",
        color_by = x,
        density_plot_ratio = 0.15,
        pt_size = 1.2,
        xlab = paste0("PC1: ", round(pca_plot_df$PC1_explained_var[1], 2), "% variance"),
        ylab = paste0("PC2: ", round(pca_plot_df$PC2_explained_var[1], 2), "% variance")
    )

    p <- p +
        plot_annotation(
            title = x,
            theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 20))
        )
    return(p)
})
final_plot <- cowplot::plot_grid(plotlist = plots, ncol= 3)
ggsave(
    plot = final_plot,
    filename = here("QC", "results", "imgs", "PCA_all_covariates_PC1_PC2.png"),
    dpi = 350,
    width = 20,
    height = 15,
)

################
# BOXPLOTS PCA #
################
plots <- lapply(columns_to_plot, function(x) {
    p <- plot_categorical_covar(
        df = pca_plot_df,
        covar = x,
        PC = paste0("PC", 1:4)
    ) %>% wrap_plots(., ncol = 2) &
        theme(
            axis.text.x = element_blank(),
            axis.text.y = element_text(size=5, face="bold")
        )
    p <- p +
        plot_annotation(
            title = x,
            theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 20))
        )
    return(p)
})
final_plot <- cowplot::plot_grid(plotlist = plots, ncol= 3)
ggsave(
    plot = final_plot,
    filename = here("QC", "results", "imgs", "PCA_all_covariates_boxplots.png"),
    dpi = 350,
    width = 20,
    height = 15,
)

##############
# UMAP PLOTS #
##############
plots <- lapply(columns_to_plot, function(x) {
    p <- density_pca(
        df = umap_plot_df,
        x_variable = "UMAP1",
        y_variable = "UMAP2",
        color_by = x,
        density_plot_ratio = 0.15,
        pt_size = 1.2,
    )
    p <- p +
        plot_annotation(
            title = x,
            theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 20))
        )
    return(p)
})
final_plot <- cowplot::plot_grid(plotlist = plots, ncol= 3)
ggsave(
    plot = final_plot,
    filename = here("QC", "results", "imgs", "UMAP_all_covariates.png"),
    dpi = 350,
    width = 20,
    height = 15,
)

################
# BOXPLOTS UMAP #
################
plots <- lapply(columns_to_plot, function(x) {
    p <- plot_categorical_covar(
        df = umap_plot_df,
        covar = x,
        PC = paste0("UMAP", 1:2)
    ) %>% wrap_plots(., ncol = 2) &
        theme(
            axis.text.x = element_blank(),
            axis.text.y = element_text(size=5, face="bold")
        )
    p <- p +
        plot_annotation(
            title = x,
            theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 20))
        )
    return(p)
})
final_plot <- cowplot::plot_grid(plotlist = plots, ncol= 3)
ggsave(
    plot = final_plot,
    filename = here("QC", "results", "imgs", "UMAP_all_covariates_boxplots.png"),
    dpi = 350,
    width = 20,
    height = 15,
)
```


## **Batch correction**

### SVA
Try out [sva](). 
`svaseq` expects normalized input data. Otherwise the first surrogate variable is often the lirbary size.
See [Jeff Leeks reply](https://support.bioconductor.org/p/76381/). We take normalized DESeq2 counts.
Internally first step of `svaseq` is log transformation so important that our normalized counts are not log transformed.

```{r}
library(sva)
dds0 <- estimateSizeFactors(dds0)
norm_counts  <- counts(dds0, normalized = TRUE)

mod  <- model.matrix(~ sampletype, colData(dds0))
mod0 <- model.matrix(~1, colData(dds0))

# important: The number of SVs matters.
# I.e. if you try 2 runs with 10 or 15, the first 10 of the run with 15 wont be the same as the other run.
svseq <- svaseq(norm_counts, mod, mod0, n.sv = 10)
saveRDS(svseq, here("QC", "results", "sva_10SV.rds"))

```

```{r}
# try and find out what the SVs correspond to. For this we can use the same functions as above
# I assume that the order in svseq does not change, because that would just be random
SVs <- svseq$sv
colnames(SVs) <- paste0("SV",1:10)
mdata <- cbind(mdata, data.frame(SVs))
covar_list = c("pool", "state", "oxldl", "oxldlset", "set", "ethnicity", "age", "batch1id")
correlation_SVs <- covar_correlation(
    df = mdata,
    covars = covar_list,
    components =paste0("SV",1:10)
)
png(here("QC", "results", "imgs", "SVA_10", "association_heatmap.png"), res=350, width=9, height=5.5, units="in")
correlation_SVs$heatmap
dev.off()

# check for association
for (x in covar_list) {
    print(x)
    p <- plot_categorical_covar(
        df = mdata,
        covar = x,
        PC = paste0("SV", 1:10),
        bonferroni_correction = TRUE
    )
    p <- lapply(p, function(k) {
        k <- k + geom_hline(yintercept = 0, linetype = "dashed")
    })

    p <- p %>% wrap_plots(., ncol = 5) &
        theme(
            axis.text.x = element_blank(),
            axis.text.y = element_text(size = 5, face = "bold")
        )
    p <- p +
        plot_annotation(
            title = x,
            theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 20))
        )
    ggsave(
        plot = p,
        filename = here("QC", "results", "imgs", "SVA_10", str_interp("SV_associations_${x}.png")),
        dpi = 350,
        width = 15,
        height = 8,
    )
}



```

However, RUVSeq does have steps to deal with sequencing depth, see vignette section 2.1, the fourth code chunk. So if you are following the RUVSeq workflow including that step you can provide original counts, not scaled counts.
https://support.bioconductor.org/p/9137741/
```{r}


dataset <- mdata[, c("pool", "batch1id", "oxldlset")] %>% sample_n(30)

cont_table <- table(dataset$pool, dataset$batch1id, dataset$oxldlset)

library(gmodels)
mosaicplot(cont_table)


mdata %>% group_by(pool, oxldlset) %>% tally



diff(range(mdata$SV1))
```



# This is the vignette for sva essentially

```{r, eval=FALSE}
library(zebrafishRNASeq)
data(zfGenes)
filter = apply(zfGenes, 1, function(x) length(x[x>5])>=2)
filtered = zfGenes[filter,]
genes = rownames(filtered)[grep("^ENS", rownames(filtered))]
controls = grepl("^ERCC", rownames(filtered))
spikes =  rownames(filtered)[grep("^ERCC", rownames(filtered))]
group = as.factor(rep(c("Ctl", "Trt"), each=3))
set = EDASeq::newSeqExpressionSet(as.matrix(filtered),
    phenoData = data.frame(group, row.names = colnames(filtered))
)
dat0 = counts(set)

## Set null and alternative models (ignore batch)
mod1 = model.matrix(~group)
mod0 = cbind(mod1[,1])

## Estimate batch with svaseq (unsupervised)
batch_unsup_sva = svaseq(dat0,mod1,mod0,n.sv=1)$sv
batch_unsup_sva_3 = svaseq(dat0,mod1,mod0,n.sv=3)$sv

batch_unsup_sva[, 1] == batch_unsup_sva_3[, 1]


```

